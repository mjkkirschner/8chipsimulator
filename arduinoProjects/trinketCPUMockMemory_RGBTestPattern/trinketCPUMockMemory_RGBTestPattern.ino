#define ENABLE 0
#define SERIAL_OUT 1
#define CLOCKPIN 2
#define TESTCLOCK 3

//replace this with 16bit hex values from somewhere.
//potentially an assembler/compiler...

const PROGMEM volatile int programLines[] = {
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,
0xF000,

0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,
0x0F00,

0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,
0x00F0,


0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
0xFFF0,
  };
const volatile int len = (sizeof(programLines)/sizeof(int));
volatile int index = 0;
//start at MSB
volatile int subindex = 0;

// the setup routine runs once when you press reset:
void setup() {
  // initialize the LED pin as an output.
  pinMode(SERIAL_OUT, OUTPUT);
  pinMode(CLOCKPIN, INPUT);
  pinMode(ENABLE, INPUT_PULLUP);
  pinMode(TESTCLOCK, OUTPUT);

  attachInterrupt(digitalPinToInterrupt(CLOCKPIN), onClock, RISING);

}

void onClock() {


  bool notEnabled = digitalRead(ENABLE);

  if(notEnabled == true){
    index = 0;
    subindex = 0;
  }
  
  //if the enable line is low  - then we can keep outputting data.
  if (notEnabled == false)
  { 
    //reset index if we overflow
    if(index == len){
      index = 0;
    }
    
    //reset subIndex when it reachs 0
    //so we can shift out the next lines data
    if(subindex == 16){
      subindex = 0;
      index = index + 1;
    }

    //first get the current word;
    int LOC =   pgm_read_word_near(programLines + index);
    //next get the current bit
    int dataBit = bitRead(LOC,subindex);
    subindex = subindex + 1;
    digitalWrite(SERIAL_OUT,dataBit);
  }
}

// the loop routine runs over and over again forever:
void loop() {

  
}
